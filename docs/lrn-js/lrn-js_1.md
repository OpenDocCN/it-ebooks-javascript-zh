# 基础

# 编程基础

在第一章，我们将学习 Javascript 的编程基础。

编程其实就是敲代码。就像一本书是包含章节，段落，句子，短语，单词最终由字母组成的一样，程序也能被切分成一块块更小的部分。对于程序，最重要的声明。声明等同于书中的句子。单独看，句子有结构和议题。但脱离了上下文，它却没有该有的意义。

声明，即非正式的(广泛的)被认为就是*一行代码*。因为声明通常被写在同一行。正是这样，程序代码通常从上到下，从左往右读。你可能会惊讶什么是代码(也就是源代码)。这是个广泛的术语，指的可以是整个程序也可以是其中最小的部分。因此，一行代码简单的说就是一行你的程序。

举个例子：

```js
var hello = "Hello";
var world = "World";

// Message equals "Hello World"
var message = hello + " " + world; 
```

这段代码能被 *解释器* 执行，并且按照正确的顺序来执行。

# 注释

注释不会被解释执行，注释被用来将代码解释给其他程序员看，或者是为了对代码作用的简单描述。因此提高代码的可读性。

在 Javascript 中，可以使用两种方式进行注释:

*   单行注释用 `//`:

```js
// 这是注释，将被解释器忽略
var a = "this is a variable defined in a statement"; 
```

*   多行注释用 `/*`开始，用`*/`结尾:

```js
/*
这是多行注释，
将被解释器忽略
*/
var a = "this is a variable defined in a statement"; 
```

Exercise 将作者的话变成注释

```js
Mark me as a comment
or I'll throw an error
```

# 变量

真正理解编程的第一步是回顾代数知识。如果你记得上学时曾学的代数，起初应该如下。

```js
3 + 5 = 8 
```

你开始执行含有未知数的计算，如下 x 代表未知数：

```js
3 + x = 8 
```

通过移项可以计算出 x：

```js
x = 8 - 3
-> x = 5 
```

当你引入不止一个更灵活的的条件 -- 你正在使用变量:

```js
x + y = 8 
```

你可以改变 x 和 y 的值，表达式依然成立:

```js
x = 4
y = 4 
```

或

```js
x = 3
y = 5 
```

编程语言都是如此。在编程中，变量是可改变值的容器。变量可以保存各种类型的值或计算结果。变量由变量名、值构成，通过中间的等号(=)将他们分开。变量名可以是任何字母或者单词，但要记住其中有一些限制，比如某些是有特殊功能的关键词。

我们来看看这是如何在 Javascript 中工作的，以下代码定义了两个变量，计算两个之和将其保存在第三个变量中。

```js
var x = 5;
var y = 6;
var result = x + y; 
```

# 数据类型

计算机很复杂并且可以使用更复杂的变量而不仅仅只是数字。数据类型就出现了。变量的出现伴随着几种类型，不同的语言支持不同的类型。

最常见的类型有:

*   **数字**
    *   **浮点型**: 一个数字, 例如 1.21323, 4, -33.5, 100004 或 0.123
    *   **整型**: 一个数字例如 1, 12, -33, 140 不可以是 1.233
*   **字符串**: 一行文本比如 "boat", "elephant" or "damn, you are tall!"
*   **布尔**: 只能表示真(True)或假(False)
*   **数组**: 一个数值的集合比如: 1,2,3,4,'I am bored now'
*   **对象**: 一种更复杂的对象的表现

JavaScript 是一种 *“弱类型”* 语言, 这意味着你不需要明确的声明变量的数据类型。你只需用`var`关键词来暗示你正在声明一个变量，解释器会从上下文(和引号)得出你用的是什么数据类型，

Exercise 用关键词 `var` 创建一个名为 `a` 的变量. `# 等式

程序猿经常需要将等价的值关联起来。这时需要用到等号。

最基础的等性运算符是 `==` 。这个运算符可以判断两个变量是否相等，即使不是相同类型。

举个例子，假设:

```js
var foo = 42;
var bar = 42;
var baz = "42";
var qux = "life"; 
```

`foo == bar` 将判定为 `true` ，而 `baz == qux` 将判定为 `false`。然而，尽管 `foo` 和 `baz` 是不同类型，`foo == baz` *也*将判定为 `true` 。 `==` 等性运算符在判断等价性之前会尝试强制将操作数转为相同类型。这与 `===` 全等运算符不同。

`===` 全等运算符判断两个变量是否类型和值 *都* 相等。在这种情况下，`foo === bar` 仍然是 `true`, 而 `foo === baz` 将为 `false`. `baz === qux` 仍为 `false`.`